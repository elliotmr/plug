package runtime

import (
	"fmt"
	"os"
	"os/exec"
	"sync"

	"github.com/elliotmr/plug/pkg/plugpb"
	"google.golang.org/protobuf/proto"
)

// Host is the internal host interface for communicating with the
// plugin. It should not be used by the plugin consumer, they should
// interface directly with the generated host implementation.
type Host struct {
	mu  sync.Mutex
	t   *transport
	cmd *exec.Cmd
}

// Load is used to launch the plugin subprocess and to wrap
// the transport logic. It should not be used directly by a user, it
// is referenced in the code that is generated by `protoc-gen-plug`.
func Load(filename string, magic string, version uint32, serviceBase Service) (*Host, error) {
	rRecv, lSend, err := os.Pipe()
	if err != nil {
		return nil, fmt.Errorf("failed to create send pipe: %w", err)
	}
	lRecv, rSend, err := os.Pipe()
	if err != nil {
		return nil, fmt.Errorf("failed to create recv pipe: %w", err)
	}

	cmd := &exec.Cmd{
		Path:   filename,
		Stdin:  rRecv,
		Stdout: rSend,
	}

	h := &Host{
		t: &transport{
			in:  lRecv,
			out: lSend,
			buf: make([]byte, os.Getpagesize()),
		},
		cmd: cmd,
	}

	err = cmd.Start()
	if err != nil {
		return nil, fmt.Errorf("unable to launch sub-process: %w", err)
	}

	return h, h.handshake(magic, version, serviceBase)
}

func (c *Host) handshake(magic string, version uint32, serviceBase Service) error {
	req := &plugpb.Handshake{
		Version: version,
		Magic:   magic,
	}
	resp := &plugpb.Handshake{}
	err := c.SendRecv(serviceBase<<8|0xFF, req, resp)
	if err != nil {
		return fmt.Errorf("failed to send handshake: %w", err)
	}
	if resp.Magic != req.Magic {
		return fmt.Errorf("magic mismatch in handshake")
	}
	if resp.Version != req.Version {
		return fmt.Errorf("version mismatch in handshake (host: %d) (plugin: %d)", req.Version, resp.Version)
	}
	return nil
}

// SendRecv is used by the generated host implementation to communicate
// with the plugin. Do not use this manually unless you want to break
// your program.
func (c *Host) SendRecv(srv Service, req, resp proto.Message) error {
	c.mu.Lock()
	defer c.mu.Unlock()
	err := c.t.send(srv, req)
	if err != nil {
		return fmt.Errorf("send error: %w", err)
	}
	srvResp, buf, err := c.t.recv()
	if err != nil {
		return fmt.Errorf("recv error: %w", err)
	}
	if srvResp != srv {
		return fmt.Errorf("recv service mismatch: %d != %d", srvResp, srv)
	}
	return proto.Unmarshal(buf, resp)
}
