// Code generated by protoc-gen-plug. DO NOT EDIT.

package example

import (
	fmt "fmt"
	runtime "github.com/elliotmr/plug/pkg/runtime"
	any "github.com/golang/protobuf/ptypes/any"
	proto "google.golang.org/protobuf/proto"
)

const (
	KVGetService       runtime.Service = 0x0000
	KVPutService       runtime.Service = 0x0001
	KVHandshakeService runtime.Service = 0x00FF
)

type KV interface {
	Get(key string) ([]byte, error)
	Put(key string, value []byte) error
}

type kvPlugin struct {
	Impl KV
}

func RunKV(impl KV) error {
	s := &kvPlugin{Impl: impl}
	return runtime.Run(s, "magic", 1, 0)
}

func (x *kvPlugin) Link(srv runtime.Service) (proto.Message, runtime.GenPluginMethod, error) {
	switch srv {
	case KVGetService:
		return &GetRequest{}, x.Get, nil
	case KVPutService:
		return &PutRequest{}, x.Put, nil
	}
	return nil, nil, fmt.Errorf("unknown service: %d", srv)
}

func (x *kvPlugin) Get(req proto.Message) (proto.Message, error) {
	in, ok := req.(*GetRequest)
	if !ok {
		return nil, fmt.Errorf("invalid request type")
	}
	value, err := x.Impl.Get(in.Key)
	return &GetResponse{Value: value}, err
}

func (x *kvPlugin) Put(req proto.Message) (proto.Message, error) {
	in, ok := req.(*PutRequest)
	if !ok {
		return nil, fmt.Errorf("invalid request type")
	}
	err := x.Impl.Put(in.Key, in.Value)
	return &Empty{}, err
}

type kvHost struct {
	c *runtime.Host
}

func LoadKV(s string) (KV, error) {
	c, err := runtime.Load(s, "magic", 1, 0)
	if err != nil {
		return nil, fmt.Errorf("unable to load plugin: %w", err)
	}
	return &kvHost{c: c}, nil
}

func (x *kvHost) Get(key string) ([]byte, error) {
	resp := &GetResponse{}
	err := x.c.SendRecv(KVGetService, &GetRequest{Key: key}, resp)
	return resp.Value, err
}

func (x *kvHost) Put(key string, value []byte) error {
	resp := &Empty{}
	err := x.c.SendRecv(KVPutService, &PutRequest{Key: key, Value: value}, resp)
	return err
}

func TestKV(impl KV) (KV, error) {
	s := &kvPlugin{Impl: impl}
	c, err := runtime.Test(s, "magic", 1, 0)
	if err != nil {
		return nil, fmt.Errorf("unable to load plugin: %w", err)
	}
	return &kvHost{c: c}, nil
}

const (
	SerializerMarshalService   runtime.Service = 0x0100
	SerializerHandshakeService runtime.Service = 0x01FF
)

type Serializer interface {
	Marshal(data map[string]*any.Any) ([]byte, error)
}

type serializerPlugin struct {
	Impl Serializer
}

func RunSerializer(impl Serializer) error {
	s := &serializerPlugin{Impl: impl}
	return runtime.Run(s, "s3rializer", 2, 1)
}

func (x *serializerPlugin) Link(srv runtime.Service) (proto.Message, runtime.GenPluginMethod, error) {
	switch srv {
	case SerializerMarshalService:
		return &MarshalRequest{}, x.Marshal, nil
	}
	return nil, nil, fmt.Errorf("unknown service: %d", srv)
}

func (x *serializerPlugin) Marshal(req proto.Message) (proto.Message, error) {
	in, ok := req.(*MarshalRequest)
	if !ok {
		return nil, fmt.Errorf("invalid request type")
	}
	data, err := x.Impl.Marshal(in.Data)
	return &MarshalResponse{Data: data}, err
}

type serializerHost struct {
	c *runtime.Host
}

func LoadSerializer(s string) (Serializer, error) {
	c, err := runtime.Load(s, "s3rializer", 2, 1)
	if err != nil {
		return nil, fmt.Errorf("unable to load plugin: %w", err)
	}
	return &serializerHost{c: c}, nil
}

func (x *serializerHost) Marshal(data map[string]*any.Any) ([]byte, error) {
	resp := &MarshalResponse{}
	err := x.c.SendRecv(SerializerMarshalService, &MarshalRequest{Data: data}, resp)
	return resp.Data, err
}

func TestSerializer(impl Serializer) (Serializer, error) {
	s := &serializerPlugin{Impl: impl}
	c, err := runtime.Test(s, "s3rializer", 2, 1)
	if err != nil {
		return nil, fmt.Errorf("unable to load plugin: %w", err)
	}
	return &serializerHost{c: c}, nil
}
