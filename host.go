package plug

import (
	"fmt"
	"os"
	"os/exec"
	"sync"

	"google.golang.org/protobuf/proto"
)

// Host is the internal host interface for communicating with the
// plugin. It should not be used by the plugin consumer, they should
// interface directly with the generated host implementation.
type Host struct {
	mu  sync.Mutex
	t   *transport
	cmd *exec.Cmd
}

// LaunchPlugin is used to launch the plugin subprocess and to wrap
// the tranport logic. It should not be used directly by a user, it
// is referenced in the code that is generated by `protoc-gen-plug`.
func LaunchPlugin(filename string) (*Host, error) {
	rRecv, lSend, err := os.Pipe()
	if err != nil {
		return nil, fmt.Errorf("failed to create send pipe: %w", err)
	}
	lRecv, rSend, err := os.Pipe()
	if err != nil {
		return nil, fmt.Errorf("failed to create recv pipe: %w", err)
	}

	cmd := &exec.Cmd{
		Path:   filename,
		Stdin:  rRecv,
		Stdout: rSend,
	}

	h := &Host{
		t: &transport{
			in:  lRecv,
			out: lSend,
			buf: make([]byte, os.Getpagesize()),
		},
		cmd: cmd,
	}

	return h, cmd.Start()
}

// SendRecv is used by the generated host implementation to communicate
// with the plugin. Do not use this manually unless you want to break
// your program.
func (c *Host) SendRecv(srv Service, req, resp proto.Message) error {
	c.mu.Lock()
	defer c.mu.Unlock()
	err := c.t.send(srv, req)
	if err != nil {
		return fmt.Errorf("send error: %w", err)
	}
	srvResp, buf, err := c.t.recv()
	if err != nil {
		return fmt.Errorf("recv error: %w", err)
	}
	if srvResp != srv {
		return fmt.Errorf("recv service mismatch: %d != %d", srvResp, srv)
	}
	return proto.Unmarshal(buf, resp)
}
