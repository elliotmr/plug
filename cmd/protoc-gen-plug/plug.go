package main

import (
	"errors"
	"fmt"
	"strings"

	"github.com/elliotmr/plug/pkg/plugpb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const (
	fmtPackage     = protogen.GoImportPath("fmt")
	runtimePackage = protogen.GoImportPath("github.com/elliotmr/plug/pkg/runtime")
	protoPackage   = protogen.GoImportPath("google.golang.org/protobuf/proto")
)

var errorf string

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + ".plug.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	errorf = g.QualifiedGoIdent(fmtPackage.Ident("Errorf"))
	g.P("// Code generated by protoc-gen-plug. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	generateFileContent(gen, file, g)
	return g
}

func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}

	for i, service := range file.Services {
		generateServiceConstants(gen, g, service, i)
		generateInterface(gen, g, service)
		generatePlugin(g, service, i)
		generateHost(g, service, i)
		generateTest(g, service, i)
	}
}

func plugName(service *protogen.Service) string {
	return strings.ToLower(service.GoName) + "Plugin"
}

func hostName(service *protogen.Service) string {
	return strings.ToLower(service.GoName) + "Host"
}

func generateServiceConstants(gen *protogen.Plugin, g *protogen.GeneratedFile, service *protogen.Service, i int) {
	if len(service.Methods) > 250 {
		gen.Error(errors.New("protoc-gen-plug only supports 250 methods per service"))
		return
	}
	s := g.QualifiedGoIdent(runtimePackage.Ident("Service"))
	g.P("const (")
	for _, method := range service.Methods {
		g.P(service.GoName, method.GoName, "Service ", s, " = 0x", fmt.Sprintf("%04X", method.Desc.Index()+i<<8))
	}
	g.P(service.GoName, "HandshakeService ", s, " = 0x", fmt.Sprintf("%04X", 255+i<<8))
	g.P(")")
}

func generateInterface(gen *protogen.Plugin, g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("type ", service.GoName, " interface {")
	for _, method := range service.Methods {
		generateInterfaceMethod(gen, g, method)
	}
	g.P("}")
	g.P("")
}

func generateInterfaceMethod(gen *protogen.Plugin, g *protogen.GeneratedFile, method *protogen.Method) {
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		gen.Error(errors.New("protoc-gen-plug does not support streaming"))
		return
	}
	var args []string
	for _, field := range method.Input.Fields {
		arg := string(field.Desc.Name()) + " " + fieldType(g, field)
		args = append(args, arg)
	}
	var rets []string
	for _, field := range method.Output.Fields {
		ret := fieldType(g, field)
		rets = append(rets, ret)
	}
	rets = append(rets, "error")

	g.P(method.GoName, "(", strings.Join(args, ", "), ") (", strings.Join(rets, ", "), ")")
}

func generatePlugin(g *protogen.GeneratedFile, service *protogen.Service, i int) {
	g.P("type ", plugName(service), " struct {")
	g.P("Impl ", service.GoName)
	g.P("}")
	g.P("")

	generatePluginRun(g, service, i)
	generatePluginLink(g, service)

	for _, method := range service.Methods {
		generatePluginMethod(g, service, method)
	}
}

func generatePluginRun(g *protogen.GeneratedFile, service *protogen.Service, i int) {
	g.P("func Run", service.GoName, "(impl ", service.GoName, ") error {")
	g.P("s := &", plugName(service), "{Impl: impl}")

	g.P("return ", g.QualifiedGoIdent(runtimePackage.Ident("Run")), launchArgs(service, i))
	g.P("}")
	g.P("")
}

func generatePluginLink(g *protogen.GeneratedFile, service *protogen.Service) {
	qService := g.QualifiedGoIdent(runtimePackage.Ident("Service"))
	qGenPluginMethod := g.QualifiedGoIdent(runtimePackage.Ident("GenPluginMethod"))
	pMessage := g.QualifiedGoIdent(protoPackage.Ident("Message"))
	g.P("func (x *", plugName(service), ") Link(srv ", qService, ") (", pMessage, ", ", qGenPluginMethod, ", error) {")
	g.P("switch srv {")
	for _, method := range service.Methods {
		g.P("case ", service.GoName, method.GoName, "Service:")
		g.P("return &", method.Input.GoIdent, "{}, x.", method.GoName, ", nil")
	}
	g.P("}")
	g.P("return nil, nil, ", errorf, "(\"unknown service: %d\", srv)")
	g.P("}")
	g.P()
}

func generatePluginMethod(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	g.P("func(x *", plugName(service), ") ", method.GoName, "(req proto.Message) (proto.Message, error) {")
	if len(method.Input.Fields) > 0 {
		g.P("in, ok := req.(*", method.Input.GoIdent, ")")
	} else {
		g.P("_, ok := req.(*", method.Input.GoIdent, ")")
	}
	g.P("if !ok {")
	g.P("return nil, ", errorf, "(\"invalid request type\")")
	g.P("}")

	var rets []string
	for _, field := range method.Output.Fields {
		ret := string(field.Desc.Name())
		rets = append(rets, ret)
	}
	retStatement := strings.Join(rets, ", ")
	if len(rets) > 0 {
		retStatement += ", "
	}
	retStatement += "err := "

	var args []string
	for _, field := range method.Input.Fields {
		arg := "in." + field.GoName
		args = append(args, arg)
	}
	argStatement := strings.Join(args, ", ")

	g.P(retStatement, "x.Impl.", method.GoName, "(", argStatement, ")")

	var wraps []string
	for _, field := range method.Output.Fields {
		wrap := field.GoName + ": " + string(field.Desc.Name())
		wraps = append(wraps, wrap)
	}
	wrapStatement := strings.Join(wraps, ", ")

	g.P("return &", method.Output.GoIdent, "{", wrapStatement, "}, err")
	g.P("}")
	g.P("")
}

func generateHost(g *protogen.GeneratedFile, service *protogen.Service, i int) {
	g.P("type ", hostName(service), " struct {")
	g.P("c *", g.QualifiedGoIdent(runtimePackage.Ident("Host")))
	g.P("}")
	g.P("")

	generateHostLoad(g, service, i)

	for _, method := range service.Methods {
		generateHostMethod(g, service, method)
	}
}

func generateHostLoad(g *protogen.GeneratedFile, service *protogen.Service, i int) {
	g.P("func Load", service.GoName, "(s string) (", service.GoName, ", error) {")
	g.P("c, err := ", g.QualifiedGoIdent(runtimePackage.Ident("Load")), launchArgs(service, i))
	g.P("if err != nil {")
	g.P("return nil, ", errorf, "(\"unable to load plugin: %w\", err)")
	g.P("}")
	g.P("return &", hostName(service), "{c: c}, nil")
	g.P("}")
	g.P("")
}

func generateHostMethod(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	var args []string
	for _, field := range method.Input.Fields {
		arg := string(field.Desc.Name()) + " " + fieldType(g, field)
		args = append(args, arg)
	}
	var rets []string
	for _, field := range method.Output.Fields {
		ret := fieldType(g, field)
		rets = append(rets, ret)
	}
	rets = append(rets, "error")

	g.P("func(x *", hostName(service), ") ", method.GoName, "(", strings.Join(args, ", "), ") (", strings.Join(rets, ", "), ") {")
	var wraps []string
	for _, field := range method.Input.Fields {
		wrap := field.GoName + ": " + string(field.Desc.Name())
		wraps = append(wraps, wrap)
	}
	wrapStatement := strings.Join(wraps, ", ")

	var resps []string
	for _, field := range method.Output.Fields {
		resp := "resp." + field.GoName
		resps = append(resps, resp)
	}
	respStatement := strings.Join(resps, ", ")
	if len(resps) > 0 {
		respStatement += ", "
	}
	respStatement += "err"

	g.P("resp := &", method.Output.GoIdent, "{}")
	g.P("err := x.c.SendRecv(", service.GoName, method.GoName, "Service, &", method.Input.GoIdent, "{", wrapStatement, "}, resp)")
	g.P("return ", respStatement)
	g.P("}")
	g.P("")
}

func generateTest(g *protogen.GeneratedFile, service *protogen.Service, i int) {
	g.P("func Test", service.GoName, "(impl ", service.GoName, ") (", service.GoName, ", error) {")
	g.P("s := &", plugName(service), "{Impl: impl}")
	g.P("c, err := ", g.QualifiedGoIdent(runtimePackage.Ident("Test")), launchArgs(service, i))
	g.P("if err != nil {")
	g.P("return nil, ", errorf, "(\"unable to load plugin: %w\", err)")
	g.P("}")
	g.P("return &", hostName(service), "{c: c}, nil")
	g.P("}")
	g.P("")
}

func fieldType(g *protogen.GeneratedFile, field *protogen.Field) string {
	fd := field.Desc
	s := ""
	if fd.IsList() {
		s += "[]"
	}
	if fd.IsMap() {
		s += "map["
		s += fieldType(g, field.Message.Fields[0])
		s += "]"
		s += fieldType(g, field.Message.Fields[1])
		return s
	}
	if msg := fd.Message(); msg != nil {
		fd.Message()
		s += "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		return s
	}
	if fd.Kind() == protoreflect.BytesKind {
		s += "[]byte"
	} else {
		s += fd.Kind().String()
	}
	return s
}

func launchArgs(service *protogen.Service, serviceIndex int) string {
	magic := proto.GetExtension(service.Desc.Options(), plugpb.E_Magic).(string)
	if magic == "" {
		magic = "magic"
	}
	version := proto.GetExtension(service.Desc.Options(), plugpb.E_Version).(uint32)
	if version == 0 {
		version = 1
	}
	return fmt.Sprintf("(s, \"%s\", %d, %d)", magic, version, serviceIndex)
}
