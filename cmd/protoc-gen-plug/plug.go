package main

import (
	"errors"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const (
	fmtPackage = protogen.GoImportPath("fmt")
	plugPackage = protogen.GoImportPath("github.com/elliotmr/plug")
	protoPackage = protogen.GoImportPath("google.golang.org/protobuf/proto")
)

var Errorf string

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + ".plug.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	Errorf = g.QualifiedGoIdent(fmtPackage.Ident("Errorf"))
	g.P("// Code generated by protoc-gen-plug. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	generateFileContent(gen, file, g)
	return g
}

func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}

	if len(file.Services) > 1 {
		gen.Error(errors.New("protoc-gen-plug requires a single service definition"))
		return
	}

	generateServiceConstants(gen, g, file.Services[0])
	generateInterface(gen, g, file.Services[0])
	generatePlugin(g, file.Services[0])
	generateHost(g, file.Services[0])
}

func generateServiceConstants(gen *protogen.Plugin, g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("const (")
	for _, method := range service.Methods {
		s := g.QualifiedGoIdent(plugPackage.Ident("Service"))
		g.P(method.GoName, "Service ", s, " = ", fmt.Sprintf("%d", method.Desc.Index()))
	}
	g.P(")")
}

func generateInterface(gen *protogen.Plugin, g *protogen.GeneratedFile, service *protogen.Service) {
	if len(service.Methods) > 250 {
		gen.Error(errors.New("protoc-gen-plug only supports 250 service methods"))
		return
	}
	g.P("type ", service.GoName, " interface {")
	for _, method := range service.Methods {
		generateInterfaceMethod(gen, g, method)
	}
	g.P("}")
	g.P("")
}

func generateInterfaceMethod(gen *protogen.Plugin, g *protogen.GeneratedFile, method *protogen.Method) {
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		gen.Error(errors.New("protoc-gen-plug does not support streaming"))
		return
	}
	var args []string
	for _, field := range method.Input.Fields {
		arg := string(field.Desc.Name()) + " " + fieldType(field.Desc)
		args = append(args, arg)
	}
	var rets []string
	for _, field := range method.Output.Fields {
		ret := fieldType(field.Desc)
		rets = append(rets, ret)
	}
	rets = append(rets, "error")

	g.P(method.GoName, "(", strings.Join(args, ", "), ") (", strings.Join(rets, ", "),")")
}

func generatePlugin(g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("type ", service.GoName, "Plugin struct {")
	g.P("Impl ", service.GoName)
	g.P("}")
	g.P("")

	generatePluginLink(g, service)

	for _, method := range service.Methods {
		generatePluginMethod(g, service, method)
	}
}

func generatePluginLink(g *protogen.GeneratedFile, service *protogen.Service) {
	qService := g.QualifiedGoIdent(plugPackage.Ident("Service"))
	pMessage := g.QualifiedGoIdent(protoPackage.Ident("Message"))
	g.P("func (x *", service.GoName, "Plugin) Link(srv ", qService, ") (", pMessage, ", plug.GenPluginMethod, error) {")
	g.P("switch srv {")
	for _, method := range service.Methods {
		g.P("case ", method.GoName, "Service:")
		g.P("return &", method.Input.GoIdent, "{}, x.", method.GoName, ", nil" )
	}
	g.P("}")
	g.P("return nil, nil, ", Errorf, "(\"unknown service: %d\", srv)")
	g.P("}")
	g.P()
}

func generatePluginMethod(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	g.P("func(x *", service.GoName, "Plugin) ", method.GoName, "(req proto.Message) (proto.Message, error) {")
	g.P("in, ok := req.(*", method.Input.GoIdent, ")")
	g.P("if !ok {")
	g.P("return nil, ", Errorf, "(\"invalid request type\")")
	g.P("}")

	var rets []string
	for _, field := range method.Output.Fields {
		ret := string(field.Desc.Name())
		rets = append(rets, ret)
	}
	retStatement := strings.Join(rets, ", ")
	if len(rets) > 0 {
		retStatement += ", "
	}
	retStatement += "err := "

	var args []string
	for _, field := range method.Input.Fields {
		arg := "in." + field.GoName
		args = append(args, arg)
	}
	argStatement := strings.Join(args, ", ")

	g.P(retStatement, "x.Impl.", method.GoName, "(", argStatement,")")

	var wraps []string
	for _, field := range method.Output.Fields {
		wrap := field.GoName + ": " + string(field.Desc.Name()) + ", "
		wraps = append(wraps, wrap)
	}
	wrapStatement := strings.Join(wraps, ", ")

	g.P("return &", method.Output.GoIdent, "{", wrapStatement,"}, err")
	g.P("}")
	g.P("")
}

func generateHost(g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("type ", service.GoName, "Host struct {")
	g.P("c *", g.QualifiedGoIdent(plugPackage.Ident("Host")))
	g.P("}")
	g.P("")

	generateHostLoad(g, service)

	for _, method := range service.Methods {
		generateHostMethod(g, service, method)
	}
}

func generateHostLoad(g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("func Load(filename string) (*", service.GoName, "Host, error) {")
	g.P("c, err := ", g.QualifiedGoIdent(plugPackage.Ident("LaunchPlugin")), "(filename)")
	g.P("if err != nil {")
	g.P("return nil, ", Errorf, "(\"unable to load plugin: %w\", err)")
	g.P("}")
	g.P("return &", service.GoName, "Host{c: c}, nil")
	g.P("}")
	g.P("")
}

func generateHostMethod(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	var args []string
	for _, field := range method.Input.Fields {
		arg := string(field.Desc.Name()) + " " + fieldType(field.Desc)
		args = append(args, arg)
	}
	var rets []string
	for _, field := range method.Output.Fields {
		ret := fieldType(field.Desc)
		rets = append(rets, ret)
	}
	rets = append(rets, "error")

	g.P("func(x *", service.GoName, "Host) ", method.GoName, "(", strings.Join(args, ", "), ") (", strings.Join(rets, ", "),") {")
	var wraps []string
	for _, field := range method.Input.Fields {
		wrap := field.GoName + ": " + string(field.Desc.Name())
		wraps = append(wraps, wrap)
	}
	wrapStatement := strings.Join(wraps, ", ")

	var resps []string
	for _, field := range method.Output.Fields {
		resp := "resp." + field.GoName
		resps = append(resps, resp)
	}
	respStatement := strings.Join(resps, ", ")
	if len(resps) > 0 {
		respStatement += ", "
	}
	respStatement += "err"


	g.P("resp := &", method.Output.GoIdent,"{}")
	g.P("err := x.c.SendRecv(", method.GoName, "Service, &", method.Input.GoIdent, "{", wrapStatement, "}, resp)")
	g.P("return ", respStatement)
	g.P("}")
	g.P("")
}


func fieldType(fd protoreflect.FieldDescriptor) string {
	s := ""
	if fd.IsList() {
		s += "[]"
	}
	if fd.IsMap() {
		s += "map[" + fd.MapKey().Kind().String() + "]"
		s += fieldType(fd.MapValue())
		return s
	}
	if msg := fd.Message(); msg != nil {
		s += "*" + string(msg.Name())
		return s
	}
	if fd.Kind() == protoreflect.BytesKind {
		s += "[]byte"
	} else {
		s += fd.Kind().String()
	}
	return s
}